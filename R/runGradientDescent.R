#' runGradientDescent
#' 
#' @keywords internal
#' @import futile.logger
#' 
#' @description Runner for gradient descent (or stochastic gradient descent) for
#' the specified number of epoch
#' 
#' @return a list containing two matrices generated by the gradient descent
runGradientDescent <- function(L0r10, R0r10, lambda, epochs, eps=0.01, block,
                               N, nnzis, nnzjs, is, js, D, m , n, r) {
    flog.debug(paste("Calculating the gradient descent for block", block))
    LR <- list(L=L0r10, R=R0r10)
    curLoss <- loss(LR$L, LR$R, lambda, N = N, is = is, js = js, D = D)
    for (epoch in seq_len(epochs)) {
        flog.debug(paste("Calculating gradient descent epoch", epoch, "of", 
                         epochs, "for block", block))
        LR <- gdepoch(LR$L, LR$R, lambda, eps, nnzis = nnzis, nnzjs = nnzjs, 
                      is = is, js = js, D = D, m = m, n = n, r = r, N = N)
        
        ## bold driver step size update
        oldLoss <- curLoss
        curLoss <- loss(LR$L, LR$R, lambda, N = N, is = is, js = js, D = D)
        if (oldLoss < curLoss) { 
            eps <- eps/2
        } else {
            eps <- eps * 1.05
        }
    }
    return(LR)
}